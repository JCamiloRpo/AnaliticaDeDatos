# -*- coding: utf-8 -*-
"""TITANIC - NS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bc4u3SNEPUGUcZ17rYVByMjMo3WpV5Xm

# Aprendizaje  No Supervisado -   TITANIC

1. Preparación de Datos
2. División de los datos
3. Aprendizaje del Modelo
4. Evaluación del Modelo
5. Predicción de Datos Futuros
"""

#Cargamos librerías principales
import numpy as np #operaciones matematics entre vectores
import pandas as pd #Manipular Estructuras de datos
import matplotlib.pyplot as plt #Libreria para realizar graficas

"""# 1. Preparación de Datos
-  Cargamos los datos
-  Conocemos los datos con estadísticos
- Seleccion de variables
- Limpieza de atipicos
- Limpieza de nulos
- Transformación de datos  (sklearn sólo analiza variables numéricas)
"""

#Cargamos los datos
data = pd.read_csv("titanic.csv", sep=",",na_values="unknown")#cargar los datos en un dateframe(Estructura de datos, donde se pude combinar diferentes datos)
data.head()#Muestra los primeros registros del dataframe

#Conocemos los datos
data.info()#Devulve informacion referente a los datos

#Corrección del tipo de datos
data['Clase']=data['Clase'].astype('category')#<dateframe>['<Columna>']=<dateframe>[<Columna>].astype('<Categoria>') convertir de tipo object al categoria
data['Edad']=data['Edad'].astype('category')
data['Sexo']=data['Sexo'].astype('category')
data['Sobrevivio']=data['Sobrevivio'].astype('category')
data.info()

#Descripción variables categóricas
data['Clase'].value_counts().plot(kind='bar')#.valuer_Counts() conteo de registros .plot(kind='bar') grafico de barras

data['Edad'].value_counts().plot(kind='bar')#.valuer_Counts() conteo de registros .plot(kind='bar') grafico de barras

data['Sexo'].value_counts().plot(kind='bar')#.valuer_Counts() conteo de registros .plot(kind='bar') grafico de barras

data['Sobrevivio'].value_counts().plot(kind='bar')#.valuer_Counts() conteo de registros .plot(kind='bar') grafico de barras

#Se codifican las categorias de la variable objetivo

dummiesClase=pd.get_dummies(data['Clase'])
data=data.drop('Clase', axis=1)
data=data.join(dummiesClase)

data['Edad']=data['Edad'].replace({"adulto": 1, "infante": 0})#como solo son 2 categorias, no es nesesario crear las dummies    .replace("<valor>"=<Valor>,"<valor>"=<Valor>)
data['Sexo']=data['Sexo'].replace({"hombre": 1, "mujer": 0})
data['Sobrevivio']=data['Sobrevivio'].replace({"si": 1, "no": 0})
data.head()

"""# 2. Aprendizaje del Modelo: K-means"""

#Creación del modelo con el conjunto de entrenamiento
from sklearn.cluster import KMeans #metodos para Knn
model = KMeans(n_clusters=6, max_iter=100)
model.fit(data)

"""# 3. Evaluación del modelo 
- Cohesion 
- Silueta(Inercia del modelo)
"""

#Inercia del modelo
print(f'inertia del modelo= {model.inertia_}')

#Evalucaion:Silueta
from sklearn import metrics
sil=metrics.silhouette_score(data,model.predict(data))
print(f'Indice de Silueta={sil}')

"""#Y si no sabemos el numero de clusters?

Método del codo
"""

#Metodo del codo para encontrar la menor cantidad de clusters
ks=range(1,20) #crear valores del 1 al< 5
inertias=[]

for k in ks:
  #crear modelo
  model=KMeans(n_clusters=k)
  model.fit(data)
  inertias.append(model.inertia_)
#graficar cantidad de clusters vs inertias
plt.plot(ks,inertias,'-o')
plt.xlabel('Numero de clusters, k')
plt.ylabel('inertia')
plt.xticks(ks)
plt.show()

"""# 4. Perfilamiento


- Aplicamos el modelo para la perfilacion
"""

#Centroides
centroides=pd.DataFrame(model.cluster_centers_, columns=data.columns.values)
centroides.round(0)

"""Cluster 7

Hombres adultos de primera clase que no sobrevivieron.

# 2. División 70-30
"""

#División 70-30
from sklearn.model_selection import train_test_split #metodo para realizar una division
#para aplicar el metodo train_test_split es nesesario separar las varibles preditoras de varible objetivo
X = data.drop("Sobrevivio", axis = 1) # Variables predictoras
Y = data['Sobrevivio'] #Variable objetivo
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.3, stratify=Y)# el metodo devuelve por separado x70,x30,y70,y30
Y_train.value_counts()

"""# 3. Aprendizaje del Modelo: Arbol de desicion"""

#Creación del modelo con el conjunto de entrenamiento
from sklearn import tree #metodos para crear aboles de desicion
model = tree.DecisionTreeClassifier(min_samples_leaf=2, max_depth=10)#.decisionTreeClassifier(<minima cantidad de registros por hoja>,<maxima profundidad de varibles(niveles)>) creacion del arbol
model.fit(X_train, Y_train)#.fit(<predictorias>,<objetivo>)metodo que realiza el aprendizaje

#Graficar el árbol
from sklearn.externals.six import StringIO  #configurar area de grafico
from IPython.display import Image  #configurar area de grafico
from sklearn.tree import export_graphviz #configurar area de grafico
import pydotplus
dot_data = StringIO()
var_predictoras = X.columns.values
nom_clases= ['no','si']# Nombres de los target in orden numérico ascendente.
export_graphviz(model, feature_names=var_predictoras, class_names= nom_clases, out_file=dot_data,filled=True, rounded=True,special_characters=True)
graph = pydotplus.graph_from_dot_data(dot_data.getvalue())  
Image(graph.create_png())